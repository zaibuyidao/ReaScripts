desc: Articulation Map
desc: Articulation Map [zaibuyidao, Tale]
version: 1.0
changelog: New Script
author: zaibuyidao, Tale
links: https://forum.cockos.com/showthread.php?t=289373
about:
  Use JSFX-Articulation Map to convert Program Change message to Keyswitches.
  In any mode, use the CC#119 controller to insert a value of 0 to immediately send Note-Off;
  You can also use CC#119 to control the length of the keyswitches in the blend mode. When the value is 64-127, the Legato mode will be activated to extend the note, and when the value is 0-63, the staccato mode will be activated and Note-Off will be sent immediately.
  
slider1:12<0,127,1{0 C-2,1 C#-2,2 D-2,3 D#-2,4 E-2,5 F-2,6 F#-2,7 G-2,8 G#-2,9 A-2,10 A#-2,11 B-2,12 C-1,13 C#-1,14 D-1,15 D#-1,16 E-1,17 F-1,18 F#-1,19 G-1,20 G#-1,21 A-1,22 A#-1,23 B-1,24 C0,25 C#0,26 D0,27 D#0,28 E0,29 F0,30 F#0,31 G0,32 G#0,33 A0,34 A#0,35 B0,36 C1,37 C#1,38 D1,39 D#1,40 E1,41 F1,42 F#1,43 G1,44 G#1,45 A1,46 A#1,47 B1,48 C2,49 C#2,50 D2,51 D#2,52 E2,53 F2,54 F#2,55 G2,56 G#2,57 A2,58 A#2,59 B2,60 C3,61 C#3,62 D3,63 D#3,64 E3,65 F3,66 F#3,67 G3,68 G#3,69 A3,70 A#3,71 B3,72 C4,73 C#4,74 D4,75 D#4,76 E4,77 F4,78 F#4,79 G4,80 G#4,81 A4,82 A#4,83 B4,84 C5,85 C#5,86 D5,87 D#5,88 E5,89 F5,90 F#5,91 G5,92 G#5,93 A5,94 A#5,95 B5,96 C6,97 C#6,98 D6,99 D#6,100 E6,101 F6,102 F#6,103 G6,104 G#6,105 A6,106 A#6,107 B6,108 C7,109 C#7,110 D7,111 D#7,112 E7,113 F7,114 F#7,115 G7,116 G#7,117 A7,118 A#7,119 B7,120 C8,121 C#8,122 D8,123 D#8,124 E8,125 F8,126 F#8,127 G8}>keyswitches
slider2:96<0,127,1>Velocity
slider3:300<0,1000,1>Delay (ms)
slider4:2<0,3,1{Staccato,Legato,Blend}>Mode
slider5:119<0,127,1{0 Bank Sel M,1 Mod Wheel M,2 Breath M,3,4 Foot P M,5 Porta M,6 Data Entry M,7 Vol M,8 Balance M,9,10 Pan M,11 Expression M,12 Ctrl 1 M,13 Ctrl 2 M,14,15,16 GP Slider 1,17 GP Slider 2,18 GP Slider 3,19 GP Slider 4,20,21,22,23,24,25,26,27,28,29,30,31,32 Bank Sel L,33 Mod Wheel L,34 Breath L,35,36 Foot P L,37 Porta L,38 Data Entry L,39 Vol L,40 Balance L,41,42 Pan L,43 Expression L,44 Ctrl 1 L,45 Ctrl 2 L,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64 Hold P sw,65 Porta sw,66 Sustenuto sw,67 Soft P sw,68 Legato P sw,69 Hold 2 P sw,70 S.Variation,71 S.Timbre,72 S.Release,73 S.Attack,74 S.Brightness,75 S.Ctrl 6,76 S.Ctrl 7,77 S.Ctrl 8,78 S.Ctrl 9,79 S.Ctrl 10,80 GP B.1 sw,81 GP B.2 sw,82 GP B.3 sw,83 GP B.4 sw,84,85,86,87,88,89,90,91 Effects Lv,92 Trem Lv,93 Chorus Lv,94 Celeste Lv,95 Phaser Lv,96 Data B. Inc,97 Data B. Dec,98 NRP L,99 NRP M,100 RP L,101 RP M,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119}>Sustain Controller (CC)
slider6:118<0,119,1{0 Bank Sel M,1 Mod Wheel M,2 Breath M,3,4 Foot P M,5 Porta M,6 Data Entry M,7 Vol M,8 Balance M,9,10 Pan M,11 Expression M,12 Ctrl 1 M,13 Ctrl 2 M,14,15,16 GP Slider 1,17 GP Slider 2,18 GP Slider 3,19 GP Slider 4,20,21,22,23,24,25,26,27,28,29,30,31,32 Bank Sel L,33 Mod Wheel L,34 Breath L,35,36 Foot P L,37 Porta L,38 Data Entry L,39 Vol L,40 Balance L,41,42 Pan L,43 Expression L,44 Ctrl 1 L,45 Ctrl 2 L,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64 Hold P sw,65 Porta sw,66 Sustenuto sw,67 Soft P sw,68 Legato P sw,69 Hold 2 P sw,70 S.Variation,71 S.Timbre,72 S.Release,73 S.Attack,74 S.Brightness,75 S.Ctrl 6,76 S.Ctrl 7,77 S.Ctrl 8,78 S.Ctrl 9,79 S.Ctrl 10,80 GP B.1 sw,81 GP B.2 sw,82 GP B.3 sw,83 GP B.4 sw,84,85,86,87,88,89,90,91 Effects Lv,92 Trem Lv,93 Chorus Lv,94 Celeste Lv,95 Phaser Lv,96 Data B. Inc,97 Data B. Dec,98 NRP L,99 NRP M,100 RP L,101 RP M,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119}>Route Channel (CC)

options:gmem=gmem_articulation_map

in_pin:none
out_pin:none

@init
cc = $xb0;
pc = $xc0;
note_on = $x90;
note_off = $x80;

head = tail = buf = 0; // delay note off queue
program = -1;

start_ons = 1024;
note_ons = start_ons;
end_ons = note_ons + 128;
memset(start_ons, -1, 128); 

@slider
delay = floor(slider3 / 1000 * srate + 0.5);
sustain = slider5;
route_channel = slider6;
gmem[1] = slider5; // get cc number

@block
while (midirecv(offset, msg1, msg2, msg3)) (
  status = msg1 & $xf0;
  channel = msg1 & $x0f;
  msg = (msg1 / 16) | 0;
  msg_num = msg2;
  msg_val = msg3;
  
  msg == 11 && msg2 == route_channel && msg3 > 0 ? (
    msg_val > 0 ? msg_val -=1;
    channel_route = msg_val % 16;
    msg1 = channel_route;
    active = 1;
  );
  
  active ? (
    msg == note_off || (msg == note_on && msg3 == 0) ? (
      msg1 = msg * 16 + note_ons[msg_num];
    ) : msg1 = msg * 16 + channel_route;
      msg == note_on && msg_val > 0 ? (
      note_ons[msg_num] = channel_route;
    );
    channel = channel_route;
  );
  
  status == cc && (msg2 == 0 || msg2 == 32) ? (
    bank_lsb = msg3;
    bank_lsb == 0 ? (
    bank_lsb = 96;
    );
    slider2 = bank_lsb;
    
    status = 0; // don't passthrough
  );
  
  status == cc && (msg2 == sustain) ? (
    ccval = msg3;
    ccval == 0 ? (
      midisend(offset, note_off + channel, slider1, 0);
    );
  );
  
  status == pc ? (
    program = msg2;
    slider1 = msg2;
    
    // Staccato Mode
    slider4 == 0 ? (
      midisend(offset, note_on + channel, program, bank_lsb);
      
      // delay note off
      tail[0] = offset + delay;
      tail[1] = note_off + channel;
      tail[2] = program;
      tail[3] = 0;
      tail += 4;
      
      program = -1;
    );
    
    // Legato Mode
    slider4 == 1 ? (
      last ? midisend(offset, note_off + channel, last, 0);
      last = program;
      midisend(offset, note_on + channel, program, bank_lsb);
    );
    
    // Blend Modes
    slider4 == 2 ? (
      ccval >= 0 && ccval <= 63 ? (
      midisend(offset, note_on + channel, program, bank_lsb);

      // delay note off
      tail[0] = offset + delay;
      tail[1] = note_off + channel;
      tail[2] = program;
      tail[3] = 0;
      tail += 4;
      
      program = -1;
      );

      ccval >= 64 && ccval <= 127 ? (
      last ? midisend(offset, note_off + channel, last, 0);
      last = program;
      midisend(offset, note_on + channel, program, bank_lsb);
      );
    );

    status = 0; // don't passthrough
  );
  
  status > 0 ? midisend(offset, msg1, msg2, msg3); // passthrough other events
);

// send any delayed events
while (head < tail && head[0] < samplesblock) (
  offset = head[0];
  msg1 = head[1];
  msg2 = head[2];
  msg3 = head[3];
  midisend(offset, msg1, msg2, msg3);
  head += 4;
);

// decrement offset of remaining delayed events
ptr = head;
while (ptr < tail) (
  offset = ptr[0];
  offset -= samplesblock;
  ptr[0] = offset;
  ptr += 4;
);

// if queue is empty then rewind
head > buf && !(head < tail) ? head = tail = buf;
